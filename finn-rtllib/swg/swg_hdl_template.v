// ==============================================================
// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and OpenCL
// Version: 2020.1
// Copyright (C) 1986-2020 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 
module $TOP_MODULE_NAME$_wb
#(
    parameter IN_WIDTH = 1, //c*bit-width
    parameter OUT_WIDTH = 1, //c*bit-width*MMV_out
    parameter BUFFER_ELEM_TOTAL = 1
)
(
    CLK,
    data_in,
    shift_enable,
    data_out
);

input CLK;
input [IN_WIDTH-1:0] data_in;
input shift_enable;
output [OUT_WIDTH-1:0] data_out;

//Input REG to enable simultaneous R/W
reg [IN_WIDTH-1:0] reg_input;

//REG FIFOs
$GENERATE_REG_FIFOS$

//BRAM FIFOs
//todo: generate real BRAM shift buffers if these get too large
$GENERATE_BRAM_FIFOS$

//Fixed REG FIFO <-> output mapping
$GENERATE_OUTPUT_MAPPING$

//main process
integer i;
always @ (posedge CLK) begin
    if (shift_enable) begin
        //shift logic
        $GENERATE_SHIFT_LOGIC$

        //shift in new data
        reg_input <= data_in;
    end
end

endmodule //window_buffer

module $TOP_MODULE_NAME$ (
        ap_clk,
        ap_rst_n,
        in0_V_V_TDATA,
        in0_V_V_TVALID,
        in0_V_V_TREADY,
        out_V_V_TDATA,
        out_V_V_TVALID,
        out_V_V_TREADY
);

//parameters
parameter BIT_WIDTH = $BIT_WIDTH$;
parameter SIMD = $SIMD$; //assuming SIMD=C for now
parameter MMV_IN = $MMV_IN$; //assuming MMV_IN=1 for now
parameter MMV_OUT = $MMV_OUT$; //assuming MMV_OUT=K for now
parameter BUF_IN_WIDTH = BIT_WIDTH * SIMD * MMV_IN; //c*bit-width
parameter BUF_OUT_WIDTH = BUF_IN_WIDTH * MMV_OUT; //c*bit-width*MMV_out

parameter CYCLES_TOTAL = $CYCLES_TOTAL$;
parameter BUF_ELEM_TOTAL = $BUF_ELEM_TOTAL$;

//IO ports
input   ap_clk;
input   ap_rst_n;
(* X_INTERFACE_PARAMETER = "FREQ_HZ 250000000.000000" *)
input  [BUF_IN_WIDTH-1:0] in0_V_V_TDATA;
input   in0_V_V_TVALID;
output   in0_V_V_TREADY;
(* X_INTERFACE_PARAMETER = "FREQ_HZ 250000000.000000" *)
output  [BUF_OUT_WIDTH-1:0] out_V_V_TDATA;
output   out_V_V_TVALID;
input   out_V_V_TREADY;

//main buffer instantiation
wire [BUF_IN_WIDTH-1:0] window_buffer_in;
wire [BUF_OUT_WIDTH-1:0] window_buffer_out;
wire window_buffer_shift_enable;
$TOP_MODULE_NAME$_wb
#(
    .IN_WIDTH(BUF_IN_WIDTH),
    .OUT_WIDTH(BUF_OUT_WIDTH),
    .BUFFER_ELEM_TOTAL(BUF_ELEM_TOTAL)
)
window_buffer_inst
(
    .CLK(ap_clk),
    .data_in(window_buffer_in),
    .shift_enable(window_buffer_shift_enable),
    .data_out(window_buffer_out)
);

//FSM state
//reg [1:0] state;
//parameter STATE_RESET = 0, STATE_OPERATE = 1, S2 = 2;

//main cycle counter (where either read/write/both happen, resets for each image)
integer cycle;
integer cycle_last;

//read/write loop state
wire read_state;
wire write_state;
reg write_done; //keep track if W of current cycle was already completed, but we still wait on a R in the same cycle

wire write_blocked;
assign write_blocked = write_state && !out_V_V_TREADY && !write_done;

wire read_ok;
// with transition to next cycle:
//              want to read      can read       source is ready (waiting on VALID allowed)
assign read_ok = read_state && !write_blocked && in0_V_V_TVALID;

wire write_ok;
// with transition to next cycle:
//              output is VALID   sink is ready  sink has already read (we are waiting on source)
assign write_ok = write_state && (out_V_V_TREADY || write_done);

wire advance;
//            includes waiting on W    if W-only cycle: wait only on W
assign advance =      read_ok        ||   (!read_state && write_ok);

//assign buffer control
//todo: if mmv_out < k: might not shift and/or write for multiple read_state cycles
assign window_buffer_shift_enable = advance;

//assign I/O ports
assign window_buffer_in = in0_V_V_TDATA;
assign out_V_V_TDATA = window_buffer_out;
assign in0_V_V_TREADY = ap_rst_n && read_ok; //only asserted if data is available and we can store it (allowed)
assign out_V_V_TVALID = ap_rst_n && write_state && !write_done; //only asserted if we have data available and it has not been read yet (don't wait for READY from sink)

//read schedule
//todo: generate differently
$GENERATE_READ_SCHEDULE$

//write schedule
//todo: generate differently
$GENERATE_WRITE_SCHEDULE$

//main process for advancing cycle count
always @ (posedge ap_clk) begin
    if (ap_rst_n == 1'b0) begin
        cycle <= 0;
        cycle_last <= 0;
    end else begin
        if (advance) begin
            write_done <= 1'b0; //reset flag

            //count cycle (completed R or W or both (depending on current cycle))
            cycle_last <= cycle; //cycle last is used to generate write_state (due to how schedule is constructed)
            if (cycle == CYCLES_TOTAL-1)
                cycle <= 0;
            else 
                cycle <= cycle+1; 
        
        end else begin
            if (write_ok) begin
                // successful W in this cycle, but R still outstanding
                write_done <= 1'b1; //write can happen even if read is blocked, but only for the current cycle!
            end
        end
    end
end

endmodule //ConvolutionInputGenerator1D_0_ConvolutionInputGenerator1D_0
