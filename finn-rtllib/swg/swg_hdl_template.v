// ==============================================================
// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and OpenCL
// Version: 2020.1
// Copyright (C) 1986-2020 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 
module window_buffer 
#(
    parameter IN_WIDTH = 1, //c*bit-width
    parameter OUT_WIDTH = 1, //c*bit-width*MMV_out
    parameter BUFFER_ELEM_TOTAL = 1
)
(
    CLK,
    data_in,
    shift_enable,
    data_out
);

input CLK;
input [IN_WIDTH-1:0] data_in;
input shift_enable;
output [OUT_WIDTH-1:0] data_out;

//Input REG to enable simultaneous R/W
reg [IN_WIDTH-1:0] reg_input;

//REG FIFOs
$GENERATE_REG_FIFOS$

//BRAM FIFOs
//todo: generate real BRAM shift buffers if these get too large
$GENERATE_BRAM_FIFOS$

//Fixed REG FIFO <-> output mapping
$GENERATE_OUTPUT_MAPPING$

//main process
integer i;
always @ (posedge CLK) begin
    if (shift_enable) begin
        //shift logic
        $GENERATE_SHIFT_LOGIC$

        //shift in new data
        reg_input <= data_in;
    end
end

endmodule //window_buffer

module $TOP_MODULE_NAME$ (
        ap_clk,
        ap_rst_n,
        in0_V_V_TDATA,
        in0_V_V_TVALID,
        in0_V_V_TREADY,
        out_V_V_TDATA,
        out_V_V_TVALID,
        out_V_V_TREADY
);

//parameters
parameter BIT_WIDTH = $BIT_WIDTH$;
parameter SIMD = $SIMD$; //assuming SIMD=C for now
parameter MMV_IN = $MMV_IN$; //assuming MMV_IN=1 for now
parameter MMV_OUT = $MMV_OUT$; //assuming MMV_OUT=K for now
parameter BUF_IN_WIDTH = BIT_WIDTH * SIMD * MMV_IN; //c*bit-width
parameter BUF_OUT_WIDTH = BUF_IN_WIDTH * MMV_OUT; //c*bit-width*MMV_out

parameter CYCLES_TOTAL = $CYCLES_TOTAL$;
parameter BUF_ELEM_TOTAL = $BUF_ELEM_TOTAL$;

//IO ports
input   ap_clk;
input   ap_rst_n;
input  [BUF_IN_WIDTH-1:0] in0_V_V_TDATA;
input   in0_V_V_TVALID;
output   in0_V_V_TREADY;
output  [BUF_OUT_WIDTH-1:0] out_V_V_TDATA;
output   out_V_V_TVALID;
input   out_V_V_TREADY;

//main buffer instantiation
wire [BUF_IN_WIDTH-1:0] window_buffer_in;
wire [BUF_OUT_WIDTH-1:0] window_buffer_out;
wire window_buffer_shift_enable;
window_buffer
#(
    .IN_WIDTH(BUF_IN_WIDTH),
    .OUT_WIDTH(BUF_OUT_WIDTH),
    .BUFFER_ELEM_TOTAL(BUF_ELEM_TOTAL)
)
window_buffer_inst
(
    .CLK(ap_clk),
    .data_in(window_buffer_in),
    .shift_enable(window_buffer_shift_enable),
    .data_out(window_buffer_out)
);

//FSM state
reg [1:0] state;
parameter STATE_RESET = 0, STATE_OPERATE = 1, S2 = 2;

//main cycle counter (where either read/write/both happen, resets for each image)
integer cycle;

//read/write loop state
wire read_state;
wire write_state;

//output registers
reg   out_V_V_TVALID_reg;

//assign buffer control
//todo: if mmv_out < k: might not shift and/or write for multiple read_state cycles
assign window_buffer_shift_enable = (read_state && in0_V_V_TVALID) || write_state;

//assign I/O ports
assign window_buffer_in = in0_V_V_TDATA;
assign in0_V_V_TREADY = read_state; //accept data whenever read loop wants to read
assign out_V_V_TDATA = window_buffer_out; //out_V_V_TDATA_reg;
assign out_V_V_TVALID = out_V_V_TVALID_reg;

//read schedule
//todo: generate differently
$GENERATE_READ_SCHEDULE$

//write schedule
//todo: generate differently
$GENERATE_WRITE_SCHEDULE$

//read process (writing to buffer)
always @ (posedge ap_clk) begin
    if (ap_rst_n == 1'b0) begin
        state <= STATE_RESET;
    end else begin
        case (state)
            STATE_RESET: begin
                state <= STATE_OPERATE;
                cycle <= 0;
            end
            STATE_OPERATE: begin
                if (read_state && in0_V_V_TVALID) begin
                    //read into buffer
                      //done in concurrent assignment
                    //count cycle (R)
                    cycle <= cycle+1;
                    if (cycle == CYCLES_TOTAL-1)
                        state <= STATE_RESET;
                end else if (write_state && out_V_V_TREADY) begin
                    cycle <= cycle+1; //count cycle (or W)
                    if (cycle == CYCLES_TOTAL-1)
                        state <= STATE_RESET;
                end
            end
        endcase
    end
end

//write process (reading from buffer)
always @ (posedge ap_clk) begin
    if (ap_rst_n == 1'b0) begin
    end else begin
        case (state)
            STATE_RESET: begin
            end
            STATE_OPERATE: begin
                if (write_state && out_V_V_TREADY) begin
                    //write from buffer
                    //todo: VALID seems to be deasserted 1 cycle too late?!
                    out_V_V_TVALID_reg <= 1'b1;
                end else begin
                    out_V_V_TVALID_reg <= 1'b0;
                end
            end
        endcase 
    end
end      

endmodule //ConvolutionInputGenerator1D_0_ConvolutionInputGenerator1D_0
